Token: Separator	Lexeme: $$
<Rat20SU>  =>   $$  <Opt Declaration List>    <Statement List> $$ 

Token: Keyword  	Lexeme: integer
<Opt Declaration List> => <Declaration List>
Token: Keyword  	Lexeme: integer
<Declaration List> -> <Declaration> ; <Declaration List Prime>
Token: Keyword  	Lexeme: integer
<Declaration> -> <Qualifier>  <Identifier>
Token: Keyword  	Lexeme: integer
<Qualifier> -> integer
<Identifier>
Identifier detected
Token: Identifier	Lexeme: i
Token: Separator	Lexeme: ;
Token: Keyword  	Lexeme: boolean
Token: Keyword  	Lexeme: boolean
<Declaration List Prime> -> <Declaration List> 
Token: Keyword  	Lexeme: boolean
<Declaration List> -> <Declaration> ; <Declaration List Prime>
Token: Keyword  	Lexeme: boolean
<Declaration> -> <Qualifier>  <Identifier>
Token: Keyword  	Lexeme: boolean
<Qualifier> -> boolean
<Identifier>
Identifier detected
Token: Identifier	Lexeme: y
Token: Separator	Lexeme: ;
Token: Keyword  	Lexeme: get
Token: Keyword  	Lexeme: get
<Declaration List Prime> -> Epsilon 
Token: Keyword  	Lexeme: get
<Statement List> -> <Statement> <Statement List Prime>
Token: Keyword  	Lexeme: get
<Statement> -> <Get>
Token: Keyword  	Lexeme: get
Token: Separator	Lexeme: (
<Identifier> -> identifier
Token: Identifier	Lexeme: max
Token: Separator	Lexeme: )
Token: Separator	Lexeme: ;

Lexeme passed in: while
Passing in: Token: Keyword  	Lexeme: while
<StatementListPrime> -> <StatementList>
Token: Keyword  	Lexeme: while
<Statement List> -> <Statement> <Statement List Prime>
Token: Keyword  	Lexeme: while
<Statement> -> <While>
<Condition> ::=     <Expression>  <Relop>   <Expression>
Token: Identifier	Lexeme: i
<Expression> -> <Term> <Expression Prime>
<Term> -> <Factor> <Term Prime>
<Factor> -> <Primary>
<Primary> -> <Identifier>
Identifier
Token: Operator  	Lexeme: <
<Term Prime> -> Epsilon
Token: Operator  	Lexeme: <
<Expression Prime> -> Epsilon
<Relop> -> <
Token: Identifier	Lexeme: max
Token: Identifier	Lexeme: max
<Expression> -> <Term> <Expression Prime>
<Term> -> <Factor> <Term Prime>
<Factor> -> <Primary>
<Primary> -> <Identifier>
Identifier
Token: Separator	Lexeme: )
<Term Prime> -> Epsilon
Token: Separator	Lexeme: )
<Expression Prime> -> Epsilon
Token: Separator	Lexeme: {
<Statement> -> <Compound>>
<Compound> -> {  <Statement List>  }
Token: Identifier	Lexeme: sum
Token: Identifier	Lexeme: sum
<Statement List> -> <Statement> <Statement List Prime>
Token: Identifier	Lexeme: sum
<Statement> -> <Assign>>
<Assign> -> <Identifier> = <Expression> ;
Token: Operator  	Lexeme: =
Token: Identifier	Lexeme: sum
Token: Identifier	Lexeme: sum
<Expression> -> <Term> <Expression Prime>
<Term> -> <Factor> <Term Prime>
<Factor> -> <Primary>
<Primary> -> <Identifier>
Identifier
Token: Operator  	Lexeme: +
<Term Prime> -> Epsilon
Token: Operator  	Lexeme: +
<Expression Prime>-> + <Term> <Expression Prime>
Token: Identifier	Lexeme: i
<Term> -> <Factor> <Term Prime>
<Factor> -> <Primary>
<Primary> -> <Identifier>
Identifier
Token: Separator	Lexeme: ;
<Term Prime> -> Epsilon
Token: Separator	Lexeme: ;
<Expression Prime> -> Epsilon
Token: Identifier	Lexeme: i
<Statement List Prime> -> Epsilon
Error: '}' expected
<Statement List Prime> -> Epsilon
Error: $$ expected.
